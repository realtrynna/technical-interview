# 네트워크
<br>

### CORS
서로 다른 오리진에서의 데이터 송수신을 허용하는 보안 정책을 의미한다. <br>
콜스 에러란 SOP(Same Origin Policy)가 다른 경우 정책에 위반되어 브라우저에서 발생시키는 에러다. <br>

* 서버에서 응답 헤더에 특정 헤더를 포함시켜 해결 <br>
* 단순 요청은 GET POST HEAD 메서드를 사용 <br>
* 사전 요청은 OPTIONS 메서드를 사용하며 실제 요청을 보내기 전 해당 리소스에 요청이 가능한지 확인하는 요청을 의미함. <br>

<br>

### GET / POST
1. GET <br>
리소스를 조회할 경우 사용하고 멱등성의 특징이 있다. <br>
주소에 데이터를 담아 보낼 수 있으며 노출되므로 민감한 정보는 포함돼서는 안된다. <br>

<br>

2. POST <br>
리소스를 생성할 경우 사용하고 데이터는 바디에 담아 보낼 수 있다. <br>

* 주소에 데이터를 담을 경우 길이의 제한이 존재하지만 바디에는 길이 제한이 없다. <br>
* POST와 PATCH를 제외한 메서드는 멱등성이 보장되어야 한다. <br>

<br>

### XSS CSRF
브라우저에서 스크립트를 실행할 수 있는 코드를 삽입하여 해커가 의도한 스크립트를 실행하는 공격 방법이다. <br>

* XSS와 CSRF의 차이는 공격이 실행되는 위치이다. <br>
* XSS는 사용자 CSRF는 서버에서 실행된다. <br>

<br>

### 프록시
클라이언트와 서버 사이에 위치한 중계기의 개념으로 대리로 통신을 수행한다. <br>

<br>

### WEB / WAS
1. WEB <br>
정적 리소스를 제공하고 리버스 프록시를 구성해 WAS 서버에 대한 정보를 숨겨 보안성을 향상시킬 수 있다. <br>
앞에 WEB 서버를 두고 뒤에 여러 개의 WAS 서버를 배치할 경우 WAS 서버에게 고르게 요청을 분배해 주는 로드밸런싱의 기능도 수행한다. <br> 

* 요청 인자 값에 따라 리소스가 변경되지 않는다. <br>

2. WAS <br>
동적 리소스를 제공하고 요청 인자 값에 따라 리소스가 변경될 수 있다. <br>

* 대부분의 WAS 서버는 WEB 서버가 수행할 수 있는 기능을 포함하고 있다. <br>

<br>

### 쿠키 / 세션
1. 쿠키 <br>
브라우저 접속 시 생성되는 Key-Value 형태로 구성된 임시 파일 <br>

* 브라우저에 저장되어 임의로 수정과 삭제가 가능하고 제3자에 의해 조회될 수 있다. <br>

<br>

2. 세션 <br>
일정 시간 동안 사용자로부터 들어온 일련의 요청을 하나의 상태로 보고 해당 상태를 유지시키는 기술 <br>

* 서버에 저장되어 쿠키에 비해 안전하지만 서버에서 다시 세션을 참조해야 하므로 사용자가 늘어날수록 그만큼의 부하가 발생한다. <br>

<br>

### 토큰
안전하게 데이터를 송수신하기 위해 JSON 형태로 구성된 Claim 기반의 웹 토큰 <br>
토큰은 서명되어 있어 신뢰할 수 있고 필요한 정보를 자체적으로 지니고 있는 자가 수용적 특징이 있다. <br>

* 구조
1. 헤더 <br>
토큰의 종류와 서명 알고리즘의 종류를 정의 <br>

2. 페이로드 <br>
사용자의 엔티티를 저장하고 토큰 만료 기간과 발급자 등을 정의 <br>

3. 시그니처 <br>
헤더와 페이로드의 인코딩(base64) 값을 결합 후 주어진 비밀 키로 해싱 한다. <br>

<br>

### 해싱 / 암호화
1. 해싱 <br>
단방향 암호화 방식이고 복호화가 불가능하다. <br>
데이터 보안에 중점을 둠 <br>

* 동일한 문자열을 동일한 해시 알고리즘을 사용하면 결과는 반드시 동일 <br>
* 서로 다른 문자열은 동일한 해시 알고리즘을 사용하면 해시값은 변경됨 <br>

> MD(Message Digest) - MD4, MD5, MD6 <br>
> SHA(Secure Hash Algorithm) - SHA, SHA-1, SHA-2, SHA-3 <br>
> RIPEMD(RIPE Message Digest) <br>
> WhirlPool

<br>

2. 암호화 <br>
양방향 암호화 방식이고 복호화가 가능하다. <br>
통신에서의 보안에 중점을 둠 <br>

* 암호화된 데이터를 받은 수신자는 복호화 키를 사용해 평문으로 복원 <br>
* 민감한 정보를 제3 자로부터 보호 <br>
* 암호화된 데이터는 권한이 없는 타인에 의해 읽힐 수 없음 <br>

> AES(Advanced Encryption Standard) <br>
> 3 DES(Triple DES) <br>
> RSA(Rivest Shamir Adleman) <br>
> ECDSA(Eliptic Curve Digital Signature Algorithm) <br>

<br>

### OAUTH
사용 서비스에 개인 정보를 제공하지 않고 기존 웹 사이트에 저장돼있는 정보에 대한 접근 권한을 부여할 수 있도록 사용되는 개방형 프로토콜 <br>

<br>

### 세션 / 토큰 인증
1. 세션 <br>
클라이언트의 정보를 서버에 저장하는 StateFul 구조 <br>

<br>

2. 토큰 <br>
클라이언트의 정보를 서버에 저장하지 않는 StateLess 구조 <br>

* 단일 도메인일 경우 세션 인증이 적합 <br>
* 세션에 사용되는 쿠키는 단일(서브) 도메인에 작동되도록 설계되어 있음 <br>

<br>

### REST
자원을 이름으로 구분해 해당 자원의 상태를 주고받는 아키텍처 스타일 <br>
자원, 행위, 표현으로 구성되어 있고 웹의 기술과 http 프로토콜을 사용함. <br>

* 자원은 HTTP URL로 구분 <br>
* 행위는 HTTP Method로 구분 <br>
* 표현은 주고받는 데이터의 형식을 의미 <br>

<br>

### REST API
REST의 특징으로 구성된 API를 의미 <br>
각 요청이 어떤 동작이나 정보를 의미하는지 모습 자체로 추론이 가능해야 함. <br>

* URL에서 접근하는 리소스에 대해 명확히 표현 <br>
* 표현하는 리소스에 동사가 들어가면 안 됨 <br>
* 자원은 URL로 행위는 Method로 결과는 Status Code로 확인 <br>

<br>

### HTTP 프로토콜
서버와 클라이언트의 구조를 가지는 데이터 송수신 규칙 <br>

1. 무상태성 (StateLess) <br>
클라이언트 요청의 상태를 저장하지 않는다. <br>

<br>

2. 비연결성 (ConnectionLess) <br>
요청에 해당하는 응답을 하면 연결을 종료함. <br>

<br>

### HTTP / HTTPS
1. HTTP <br>
TCP와 직접 통신하며 데이터는 평문으로 송수신되어 제3자에 의해 조회될 수 있다. <br>

<br>

2. HTTPS <br>
HTTP는 SSL과 SSL은 TCP와 통신하며 데이터는 암호화되어 송수신된다. <br>
제3자에 의해 조회되더라도 키가 탈취되지 않는 이상 조회한 데이터를 복호화 할 수 없다. <br>

<br>

### TCP / UDP
1. TCP <br>
데이터 송수신을 위해 IP를 이용하는 연결 지향형 프로토콜 <br>

* 3-Way-Handshake를 통해 연결하고 4-Way-Handshake를 통해 연결을 종료함. <br>
* 오류와 혼잡 제어 가능 <br>

<br>

2. UDP <br>
비 연결형 프로토콜이며 통신 간에 신뢰성을 보장하지 않고 IP를 그대로 사용해 단순 CheckSum 말고는 데이터의 훼손을 감지할 수 없다. <br>
중간에 데이터가 유실되어도 다시 요청할 수 있는 방법이 없음. <br>

* 오류와 혼잡 제어 불가능 <br>

<br>

### 3-Way-Handshake
TCP/IP 프로토콜을 이용해 통신하는 응용 프로그램이 데이터를 송수신 하기 전 신뢰성 있는 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정 <br>

<br>

1. 클라이언트는 서버로 SYN 플래그를 보냄. <br>
2. 서버는 클라이언트로 SYN과 ACK 플래그를 보냄. <br>
3. 클라이언트는 서버로 ACK 플래그를 보내면서 연결이 이루어짐. <br>

<br>

### 4-Way-Handshake
TCP/IP 프로토콜 연결을 종료하기 위해 클라이언트와 서버가 연결된 세션을 종료하는 과정 <br>

<br>

1. 클라이언트는 서버에게 FIN 플래그를 보냄. <br>
2. 서버는 클라이언트에게 ACK 플래그를 보내고 연결 종료 시까지 기다림. <br>
3. 연결 종료 후 서버는 클라이언트에게 FIN 플래그를 보냄. <br>
4. 클라이언트는 서버에게 ACK 플래그를 보내며 연결이 종료됨. <br>

* 3번 과정에서 플래그보다 데이터가 늦게 도착할 경우 Packet이 유실되는데 유실을 방지 하기위해 잉여 Packet을 기다리는 Time-Wait 과정이 존재함. <br>

<br>

### URI URL
1. URI <br>
네트워크 상의 자원을 나타내는 고유 식별자 <br>

* 리소스를 고유하게 식별 <br>

<br>

2. URL <br>
네트워크 상의 자원의 위치를 나타냄. <br>
리소스가 어디 있고 어떻게 접근할 수 있는지를 의미 <br>

<br>

### 대칭키 / 비대칭키
1. 대칭키 <br>
데이터 암호/복호화 하는 데 있어 사용되는 키가 동일 <br>

<br>

2. 비대칭키 <br>
대칭키와 반대로 암호/복호화에 사용되는 키가 다름 <br>

<br>

### OSI 7 Layer
네트워크 통신 과정을 계층별로 개념화한 모델 <br>

<br>

1. 물리 계층 <br>
전기적 데이터의 전송을 담당한다. <br>
데이터의 내용이 뭐고 에러가 발생했는지에 대한 통신 과정은 관여하지 않는다. <br>

* 전송 단위는 Bit, 통신 케이블과 허브를 사용 <br>

<br>

2. 데이터 링크 계층 <br>
물리 계층을 통해 송수신되는 데이터의 오류와 흐름을 관리하고 안전한 데이터의 전달을 수행함. <br>
시스템들 간의 신뢰성을 보장하며 재전송의 기능도 수행함. <br>

* 전송 단위는 Frame, 브릿지와 스위치를 사용하고 Ethernet 프로토콜을 사용 <br>

<br>

3. 네트워크 계층 <br>
논리적인 주소 체계와 라우팅을 지원함. <br>
데이터가 원하는 목적지까지 성공적으로 전달될 수 있도록 함. <br>

* 전송 단위는 Packet, 라우터를 사용하고 IP, ARP, ICMP 프로토콜을 사용 <br>

<br>

4. 전송 계층 <br>
프로세스 간의 통신을 담당하고 포트 번호를 정의한다. <br>
오류와 흐름 제어 다중화를 수행함. <br>

* 전송 단위는 Segment, TCP/UDP와 게이트 L4 프로토콜을 사용 <br>

<br>

5. 세션 계층 <br>
응용 프로세스가 통신을 관리하기 위한 방법을 제공함. <br>
동시 송수신(Duplex)과 반이중(Half Duplex)과 전이중(Full Duplex) 통신을 포함함. <br>
네트워크 사이에 상호작용을 설정/유지하고 동기화의 역할도 수행함. <br>

* 체크 포인트를 설정해 전송 도중 연결이 끊어지거나 충돌이 발생할 경우 마지막 체크 포인트에서 세션을 재개함. <br>
* 전송 단위는 Data, NetBIOS SSH TLS 프로토콜을 사용 <br>

<br>

6. 표현 계층 <br>
서로 다른 데이터 표현방식을 사용하는 응용 프로세스가 통신할 수 있도록 데이터 형식과 표현을 다루는 역할을 수행함. <br>
세션 계층에서 받은 데이터를 응용 계층으로 보내기 전 적절한 데이터의 형태로 변환함. <br>

* 전송 단위는 Data, ASCII JPEG MPEG 프로토콜을 사용 <br>

<br>

7. 응용 계층 <br>
소프트웨어 사용자와의 인터페이스를 담당함. <br>
응용 프로세스와 직접 관계하여 일반적으로 수행되는 응용 서비스를 수행함. <br>

* 전송 단위는 Data, DNS FTP HTTP 프로토콜을 사용 <br>

<br>

### Base64
바이너리 데이터를 텍스트로 변환하는 인코딩 방법 중 하나 <br>

* 바이너리 데이터를 Character Set에 영향을 받지 않는 공통 ASCII 영역의 문자열로 변환하는 과정 <br>
* 인코딩을 하게 되면 전송해야 할 데이터의 크기가 증가 <br>
* 6비트 당 2비트의 오버헤드가 발생 <br>













