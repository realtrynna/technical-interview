# 타입스크립트
<br>

### 배열 메서드
### ESM / CJS
1. ESM <br>
ES6 모듈을 의미하며 import/export 키워드로 모듈들을 가져오고 내보내는 방식이다. <br>

<br>

2. CJS <br>
CommonJS 모듈을 의미하며 require/exports 키워드로 모듈들을 가져오고 내보내는 방식이다. <br>

<br>

> ESM은 strict 모드가 기본적으로 설정돼있고 번들링 시 파일의 크기가 증가하지 않는다. <br>
> CJS는 strict 모드를 걸어주어야 하고 번들링 시 파일의 크기가 증가한다. <br>
> 최신은 ESM 모듈 방식을 사용하지만 CJS 모듈을 사용했던 프로젝트들도 있어 둘 다 효과적으로 사용할 수 있어야한다. <br>

<br>

### var / let / const
var는 함수 스코프 let과 const는 블록 스코프다. <br>
var는 호이스팅의 특징이 있으며 재선언, 재할당 할 수 있다. <br>
let은 재선언은 불가능하지만 재할당이 가능하다. <br>
const는 재선언, 재할당 할 수 없다. <br>

<br>

### undefined / null
undefined와 null 모두 값이 없음을 나타낸다. <br>
명시적으로 없음을 나타낼 경우 null을 사용한다. <br>

* typeOf null은 object인데 이는 자바스크립트 설계 에러이며 일치 연산자(===)를 활용해 검증해야 한다. 

<br>

### 호이스팅
코드 실행 시 변수와 함수의 선언이 스코프 최상단으로 끌어올려지는 현상을 의미한다. <br>

* var와 함수 선언문에서 발생하며 let, const, 함수 표현식에서는 발생하지 않는다. <br>
* var는 선언과 동시에 초기화가 이루어지므로 undefined가 할당된다. <br>

<br>

### 원시 타입 / 참조 타입
1. 원시 타입 <br>
불변 값이며 데이터가 변수에 할당되면 메모리 상에 고정된 크기로 저장되고 해당 변수가 원시 데이터의 값을 보관한다. <br>

<br>

2. 참조 타입 <br>
가변 값이며 데이터의 크기는 정해져 있지 않고 변수 할당 시 변수에 저장되는 게 아니라 데이터에 대한 주소를 저장한다. <br>

<br>

### 얕은 복사 / 깊은 복사
1. 얕은 복사 <br>
참조 타입 데이터가 저장한 메모리 주소 값을 복사한다. <br>
원본 값과 복사된 값이 같은 메모리 주소를 가리키며 복사된 값이 수정될 경우 원본 값도 수정된다. <br>

<br>

2. 깊은 복사 <br>
새로운 메모리 공간을 확보해 완전히 복사한다. <br>
복사된 데이터가 다른 주소를 참조하며 내부의 값을 복사한다. <br>

<br>

### 콜 스택 / 메모리 힙
1. 콜 스택 <br>
원시 타입의 데이터가 저장되며 실행 컨텍스틀 통해 변수 식별자를 저장하고 this와 코드 실행 순서를 관리한다. <br>

<br>

2. 메모리 힙 <br>
참조 타입 데이터가 저장되며 메모리 할당이 일어나는 공간이다. <br>
크기는 런타임 단계에서 동적으로 결정되며 구조화되어있지 않다. <br>

<br>

### 이벤트 루프 
libuv 내부에 존재하는 구현체다. <br>
본래 싱글 스레드는 한 번에 하나의 작업을 처리할 수 있지만 이벤트 루프를 통해 논 블로킹 방식으로 작업을 처리한다. <br>

<br>

### 동기 / 비동기
실행과 동시에 결과값이 기대되는 경우를 동기 그렇지 않은 경우를 비동기라고 한다. <br>

1. 동기 <br>
직렬로 실행되며 하나의 작업이 끝날 시점까지 다음 작업은 대기해야 하며 기존 작업이 종료되어야 실행될 수 있다. <br>

<br>

2. 비동기 <br>
병렬로 실행되며 기존 작업의 완료 여부와 관계 없이 다음 작업의 실행이 이루어진다. <br>

<br>

### 프로미스
내용은 실행되었지만 결과를 반환하지 않은 객체다. <br>
then을 만나기 전까지 동기적으로 실행되며 resolve와 reject는 각각 성공과 실패를 의미한다. <br>
콜백과 다르게 실행할 함수를 분리할 수 있고 원하는 시점에 호출할 수 있다. <br>

<br>

### async / await
프로미스의 단점을 보완한 문법이며 비동기 코드를 동기 코드처럼 작성할 수 있다. <br>

* 프로미스와의 차이점은 에러 핸들링과 코드 가독성의 차이가 있다.

<br>

### 콜백 함수
함수의 파라미터로 함수를 전달받은 함수를 의미한다. <br>
제어권은 전달된 함수에게 있으며 비동기 프로그래밍 방식의 문제점을 해결할 수 있지만 콜백 지옥과 에러 처리에 어려움이 있다. <br>

<br>

### 콜백 지옥
콜백 함수가 반복되어 코드의 들여 쓰기 수준이 감당하기 힘들 정도로 깊어지는 현상을 의미한다. <br>

<br>

### this
실행되는 주체에 따라 동적으로 변하는 자기 참조 변수다. <br>

<br>

1. 전역 공간에서의 this는 전역 객체에 바인딩 된다. <br>
2. 메서드로 호출되는 this는 메서드 호출 주체에 바인딩 된다. <br>
3. 함수로써 호출되는 this는 젼역 객체에 바인딩 되며 메서드 내부 함수에서도 동일하다. <br>
4. 콜백 함수 내부에서 호출되는 this는 제어권을 넘겨받은 함수가 정의한 주체에 바인딩 되며 정의하지 않은 경우 전역 객체에 바인딩 된다. <br>
5. 생성자 함수에서의 this는 생성될 인스턴스에 바인딩 된다. <br>

<br>

### TDZ
let 또는 const 또는 함수 표현식 선언 시 선언 이전에 식별자를 참조할 수 없는 구역을 의미한다. <br>

* var, 함수 선언문, import는 호이스팅되므로 TDZ에 해당되지 않음 <br>

<br>

### 실행 컨텍스트
실행될 코드에 제공할 환경 정보들을 모아놓은 객체다. <br>
활성화되는 시점에 variableEnvironment와 lexicalEnvironment 그리고 thisBinding을 수집한다. <br>

* 실행 컨텍스트 생성 시 variableEnvironment와 lexicalEnvironment는 동일한 내용으로 구성되지만 lexicalEnvironment는 variableEnvironment와 다르게 변경 사항이 실시간으로 반영된다. <br>

* 실행 컨텍스트 생성 시 variableEnvironment에 정보(식별자와 외부 환경 정보)들을 먼저 담은 후 이를 그대로 복사해 lexicalEnvironment를 만들고 이후에는 lexicalEnvironment를 활용한다. <br>

* variableEnvironment와 lexicalEnvironment는 environmentRecord와 outerEnvironmentReference로 구성된다. <br>

* environmentRecord에는 현재 컨텍스트와 관련된 코드의 식별자 정보들이 저장된다. <br>


